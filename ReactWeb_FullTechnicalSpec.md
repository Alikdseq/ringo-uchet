## Полный технический аудит приложения Ringo Uchet для реализации нового фронтенда на Next.js

### Статус реализации фронтенда (Next.js)

- [x] Базовый каркас Next.js, Tailwind, React Query, Zustand, `httpClient` с interceptor’ами.
- [x] Сценарий 2.1: Авторизация и автологин (страница `/login`, автоподнятие сессии, refresh токена).
- [x] Сценарий 2.2: Создание новой заявки (`/orders/create`):
  - клиент (поиск/создание),
  - адрес, описание, операторы,
  - номенклатура с расчётом суммы,
  - примерная стоимость и флаг «Одобрить при создании».
- [x] Сценарий 2.3: Просмотр заявки и смена статусов (`/orders/[orderId]`):
  - карточка заявки,
  - таймлайн статусов,
  - диалог смены статуса с комментарием.
- [x] Сценарий 2.4: Завершение заявки (`/orders/[orderId]/complete`):
  - `end_dt`, комментарий, зарплата операторов.
- [x] Сценарий 2.5: Просмотр отчётов (`/reports/summary`, `/reports/equipment`, `/reports/employees`) — базовая версия.
- [x] Каталог: техника, услуги, материалы, клиенты (страницы списка, поиск, базовые действия).
- [x] Профиль пользователя и смена пароля.
- [x] Оффлайн‑очередь на уровне инфраструктуры (HTTP‑клиент и сервис очереди).
- [x] Полный UI оффлайн‑очереди (`/offline-queue`, индикатор в layout).
- [x] Экран и логика настроек уведомлений (`/profile/notifications` + `/notifications/preferences`).
- [x] Полная интеграция web push / регистрации токена устройства (service worker + `/notifications/device-tokens/`).
- [ ] Дополнительные улучшения UI (карта на карточке заявки, предпросмотр чека и т.п.).

Этот документ объединяет в себе:
- фактическую архитектуру Flutter‑клиента и Django backend;
- структуру экранов, сценариев и ролей;
- карту стейта, навигации и компонентов;
- маппинг всего этого в новый фронтенд на Next.js 14 (App Router).

Цель: по этому файлу можно **пошагово** реализовать новый веб‑фронт, не возвращаясь к коду Flutter/Django.

---

## ЧАСТЬ 1. ОБЩИЙ ОБЗОР ПРИЛОЖЕНИЯ

### 1.1 Название и назначение

- **Название**: Ringo Uchet.
- **Назначение**: система учёта и управления заявками на работы со спецтехникой и материалами (земляные работы, техника, грунт, топливо, зарплаты операторов и т.д.).
- **Что решает**:
  - централизует заявки между менеджерами и операторами;
  - связывает заявки с техникой, материалами, расходами и зарплатами;
  - даёт управленческую отчётность (выручка, расходы, маржа, загрузка техники, эффективность сотрудников);
  - поддерживает **оффлайн‑работу** и отложенную синхронизацию.

### 1.2 Целевые роли и пользователи

- **Администратор (`admin`)**
  - Полный доступ.
  - Управляет пользователями, номенклатурой, отчётами.
  - Может видеть и менять любые заявки, удалять их, править завершённые.
- **Менеджер (`manager`)**
  - Создаёт и сопровождает заявки.
  - Назначает операторов, ведёт клиентов, работает с каталогом.
  - Видит отчёты (summary/equipment/employees).
- **Оператор (`operator`)**
  - Видит только **свои** заявки.
  - Фактически выполняет работы: старт/завершение заявки, фиксация объёмов, добавление фото.
  - Видит историю собственной зарплаты.

### 1.3 Ключевые возможности (фичи)

- **Управление заявками (Orders)**:
  - статусы `DRAFT → CREATED → APPROVED → IN_PROGRESS → COMPLETED / CANCELLED`;
  - назначение нескольких операторов;
  - черновики, автосохранение;
  - расчёт стоимости из номенклатуры или по примерной сумме.
- **Каталог номенклатуры (Catalog)**:
  - техника (`Equipment`) с почасовой/дневной ставкой, статусом, атрибутами;
  - услуги (`ServiceItem`), материалы (`MaterialItem`), навески (`Attachment`);
  - привязка навесок к технике, учёт обслуживания.
- **Клиенты (CRM)**:
  - юридические и физические лица (`Client`), реквизиты, адрес/геопозиция;
  - связь клиента с заказами и биллингом.
- **Финансы и отчёты (Finance/Reports)**:
  - выручка, расходы, маржа, загрузка техники, эффективность сотрудников;
  - зарплаты операторов (`SalaryRecord`), расходы на топливо/ремонт (`Expense`);
  - отчёты `Summary`, `Equipment`, `Employees`, с кэшем и экспортом.
- **Уведомления (Notifications)**:
  - push через FCM, настройки предпочтений по событиям;
  - device tokens и подписки.
- **Оффлайн‑режим**:
  - кэш заявок/каталога/отчётов;
  - очередь действий (создание/редактирование/завершение заявок, смена статусов);
  - фоновый sync при восстановлении сети.

### 1.4 Высокоуровневая архитектура

**Клиент (Flutter / новый Next.js фронт)**  
→ **API Gateway (Django REST Framework)**  
→ **Доменные модели и сервисы (Orders, Catalog, CRM, Finance, Users, Notifications)**  
→ **База данных (реляционная SQL, через Django ORM)**  
→ **Внешние сервисы**:
- AWS S3/совместимое хранилище — вложения и фото (presigned upload);
- Firebase/FCM — push‑уведомления;
- Redis/кэш — кэш отчётов, с функцией сброса при обновлении данных;
- Prometheus/metrics — мониторинг (`/metrics`);
- Sentry/Firebase Crashlytics — логирование ошибок (со стороны Flutter).

**Основные API‑узлы (см. `ringo_backend/api_urls.py`):**
- `/api/v1/token/`, `/token/refresh/`, `/token/blacklist/` — аутентификация.
- `/api/v1/users/...` — профиль, операторы, смена пароля, зарплата оператора.
- `/api/v1/equipment`, `/services`, `/materials`, `/clients` — номенклатура и клиенты.
- `/api/v1/orders` — CRUD заявок и действия (`/status/`, `/complete/`, `/receipt/`, `/generate_invoice/`, `/attachments/`, `/delete/`).
- `/api/v1/reports/summary`, `/equipment`, `/employees` — отчёты.
- `/api/v1/notifications/...` — токены устройств, подписки и предпочтения.

---

## ЧАСТЬ 2. ПОЛЬЗОВАТЕЛЬСКИЕ СЦЕНАРИИ (USER JOURNEY MAP)

Ниже — ключевые сценарии для **менеджера/админа** и **оператора**, в формате, который можно один-в‑один перенести в Next.js страницы и хуки.

### 2.1 Сценарий: Авторизация и автологин

**Роли**: все.  
**Веб‑маршруты**: `/login`, `/register`, `/` (домашняя).

#### Входная точка
- Пользователь открывает веб‑приложение:
  - если есть кэш пользователя и токены → попытка авто‑логина;
  - иначе — редирект на `/login`.

#### Шаги (UI‑взаимодействие)

1. **Экран `/login`**
   - Элементы:
     - Поле `Телефон` (строка, маска/валидация, допускает `+7`, пробелы и т.п.).
     - Поле `Email` (опционально).
     - Поле `Пароль`.
     - Чекбокс `Запомнить меня` (влияет на сохранение кредов).
     - Кнопка `Войти`.
   - Действие пользователя:
     - вводит телефон **или** email + пароль;
     - нажимает `Войти`.
   - Локальная валидация:
     - хотя бы одно из полей `телефон/email` не пустое;
     - пароль не пустой.
   - Визуальный отклик:
     - состояние кнопки `loading`;
     - блок с ошибкой очищается перед новым запросом.

#### Взаимодействие с backend

- **Эндпоинт**: `POST /api/v1/token/`
  - Тело:
    - один из: `phone`, `email`, `username`;
    - `password`.
  - Пример:
    ```json
    {
      "phone": "+7 999 123-45-67",
      "password": "secret"
    }
    ```
- **Момент вызова**: при нажатии `Войти` после локальной валидации.
- **Успех (200)**:
  - фронт сохраняет:
    - `access`, `refresh`;
    - телефон/email и пароль (если включено «запомнить»);
    - `user` (из ответа или из `GET /users/me/` сразу после логина);
  - глобальное состояние auth обновляется;
  - происходит навигация на `/` (дашборд) с плавной анимацией.
- **Ошибка (401 / 400)**:
  - показывается красный блок:
    - текст из `{"detail": "Неверный телефон, email или пароль"}`;
  - поле пароля очищается, телефон/email остаются.
- **Ошибка сети / timeout**:
  - показывается баннер «Нет соединения»;
  - предложение работать в оффлайн‑режиме (если есть кэш пользователя).

#### Автологин (фоновые шаги)

1. При загрузке приложения:
   - Next‑фронт вызывает `initAuth()`:
     - читает `access`, `refresh`, `userJson`, сохранённые креды.
2. Если есть `userJson`:
   - пользователь считается аутентифицированным **немедленно**;
   - UI показывает основной layout, даже если сеть недоступна.
3. Если есть `refresh`:
   - фоновой запрос `POST /api/v1/token/refresh/`:
     - при успехе обновляет `access`;
     - при 401 — падает обратно к авто‑логину по сохранённым кредам.
4. Если только креды:
   - тихий вызов `POST /api/v1/token/` без показа `/login`:
     - при успехе пользователь остаётся на текущем экране;
     - при неуспехе — перевод на `/login`.

---

### 2.2 Сценарий (Менеджер/Admin): Создание новой заявки

**Роли**: `admin`, `manager`.  
**Веб‑маршрут**: `/orders/create`.

#### Входная точка
- Из главного экрана (`/`):
  - кнопка `Создать заявку` в блоке быстрых действий.
- Из списка заявок (`/orders`):
  - кнопка `+` в правом верхнем углу.

#### Шаг за шагом

1. **Экран `Создание заявки`**
   - Элементы:
     - Блок «Клиент»:
       - Поле `Название/ФИО клиента` (обязательно).
       - Поле `Телефон` (обязательно).
       - Поле `Email` (опционально).
       - Кнопка `Выбрать из клиентов` (открывает диалог со списком `/clients`).
     - Блок «Данные заявки»:
       - Поле `Адрес` (обязательно).
       - Поле `Описание` (текст).
       - Поле выбора `Дата/время начала` (`start_dt`).
     - Блок «Операторы»:
       - Мультиселект `Операторы` (по данным `GET /users/operators/`).
     - Блок «Номенклатура» (опциональный):
       - Список выбранных позиций (пока пуст).
       - Кнопка `Добавить позицию`.
     - Блок «Финансы»:
       - Поле `Примерная стоимость (₽)` (может быть пустым).
       - Переключатель `Одобрить сразу` (определяет `status`).
     - Кнопки:
       - `Создать заявку` (primary).
       - `Отмена` / `Назад`.
   - Визуальный отклик:
     - при вводе ошибок — подсветка полей, inline‑сообщения;
     - при выборе номенклатуры — обновление списка позиций и предпросмотр суммы.

2. **Диалог выбора номенклатуры**
   - Навигация: modal / dialog поверх страницы.
   - Табы:
     - `Техника` (`/equipment`),
     - `Услуги` (`/services`),
     - `Материалы` (`/materials`).
   - Фильтры и поиск:
     - строка поиска, фильтрация по статусу/категории.
   - Действие:
     - пользователь выбирает одну или несколько позиций;
     - задаёт количество, при необходимости — скидку, налог.
   - Визуальный отклик:
     - предпросмотр итога (через локальный расчёт или `/orders/{id}/calculate/preview/`).

#### Валидации и бизнес‑логика на клиенте

- Обязательны: клиент (имя + телефон), адрес, `start_dt`.
- Не должны конфликтовать:
  - если есть номенклатура (`items`), поле `Примерная стоимость` используется только как вспомогательное значение и **не определяет** финальный `total_amount`.
- Дополнительное:
  - телефон приводится к формату, совместимому с backend.
  - при отсутствии операторов — заявка может быть создана без привязки.

#### Взаимодействие с backend

1. **Работа с клиентом**
   - Если выбран существующий клиент:
     - используем его `id` напрямую.
   - Если вводится новый:
     - **Эндпоинт**: `POST /api/v1/clients/`
     - Тело (минимум):
       ```json
       {
         "name": "ООО Ромашка",
         "phone": "+79991234567",
         "address": "Москва, ул. Ленина, 10"
       }
       ```
     - Ответ: объект `Client` с полем `id`.

2. **Создание заявки**
   - **Эндпоинт**: `POST /api/v1/orders/`
   - Тело:
     - `client_id`: `number | null`;
     - `address`: `string`;
     - `start_dt`: `ISO‑строка`;
     - `description`: `string`;
     - `operator_ids`: `number[]` (мультиоператоры);
     - `prepayment_amount?`: `number`;
     - либо:
       - `items`: `OrderItem[]` (если задана номенклатура);
       - либо `total_amount`: `number` (примерная стоимость).
     - `status`: `CREATED` или `APPROVED` в зависимости от переключателя.
   - Backend:
     - генерирует `number`, если он не передан;
     - при наличии `items` полностью считает `total_amount` из номенклатуры;
     - записывает `created_by`, `manager` текущим пользователем.

3. **Обработка ответа**
   - Успех:
     - переходим на `/orders` или `/orders/[id]`;
     - показываем toast «Заявка создана».
   - Ошибки валидации:
     - показываем ошибки по полям (структура DRF);
   - Ошибка сети:
     - предлагаем сохранить заявку в оффлайн‑очередь и синхронизировать позже.

#### Итог для пользователя

- Заявка появляется в списке с нужным статусом.
- Менеджер может сразу открыть её и начать назначать ресурсы/менять статус.

---

### 2.3 Сценарий (Менеджер/Admin): Работа с заявкой и смена статусов

**Роли**: `admin`, `manager`, частично `operator`.  
**Веб‑маршруты**: `/orders`, `/orders/[orderId]`.

#### Входная точка

- Менеджер переходит в `/orders` и выбирает заявку из списка (`OrdersList`).
- Оператор видит только свои заявки (фильтрация backend по операторам).

#### Шаги и UI

1. **Список заявок (`/orders`)**
   - Элементы:
     - Табы по статусам (`Все`, `CREATED`, `APPROVED`, `IN_PROGRESS`, `COMPLETED`, `CANCELLED`);
     - Поисковая строка;
     - Таблица/карточки заявок.
   - Действие:
     - пользователь кликает по строке/карточке заявки.
   - Навигация:
     - `router.push('/orders/[id]')`.

2. **Деталь заявки (`/orders/[id]`)**
   - Блок статуса:
     - бейдж со статусом;
     - кнопка `Изменить статус` (если роль и текущий статус позволяют);
     - кнопка `Удалить` (admin/manager).
   - Диалог смены статуса:
     - выпадающий список доступных статусов (по текущему состоянию;
       логика ограничений — как в `_validate_status_transition` backend);
     - поле `Комментарий`;
     - опционально `operator_salary` (для обратной совместимости).

#### Взаимодействие с backend

- **Получение заявки**: `GET /api/v1/orders/{id}/`.
- **Смена статуса**:
  - `PATCH /api/v1/orders/{id}/status/`:
    ```json
    {
      "status": "APPROVED",
      "comment": "Согласовано с клиентом"
    }
    ```
  - Backend:
    - валидирует допустимость перехода (`_validate_status_transition`);
    - создаёт `OrderStatusLog` запись;
    - обновляет поле `status` у заявки;
    - отправляет уведомление.
- **Удаление заявки**:
  - `POST /api/v1/orders/{id}/delete/`
  - Backend:
    - удаляет расходы и зарплаты, связанные с заявкой;
    - физически удаляет заявку;
    - чистит кэш отчётов.

#### Итоговый результат

- Пользователь видит обновлённый статус/удаление на списке.
- Отчёты после удаления/завершения учитывают изменения (через сброс кэша).

---

### 2.4 Сценарий (Оператор): Выполнение и завершение заявки

**Роль**: `operator`.  
**Веб‑маршруты**: `/orders`, `/orders/[id]`, `/orders/[id]/complete`.

#### Входная точка

- Оператор логинится → попадает на `/orders` с фильтром «мои заявки».
- Из списка выбирает заявку в статусе `IN_PROGRESS`.

#### Шаги

1. **Просмотр заявки**
   - В блоке статуса доступна кнопка `Завершить работу`.
   - При клике:
     - открывается экран `/orders/[id]/complete`.

2. **Экран завершения (`/orders/[id]/complete`)**
   - Блок `Фактическое время`:
     - поле `Дата/время окончания (end_dt)` — обязательное.
   - Блок `Номенклатура`:
     - список позиций (если есть);
     - кнопка «Изменить» → диалог выбора:
       - техника (`/equipment`);
       - материалы (`/materials`);
       - услуги (`/services`).
     - для каждой позиции техники:
       - поля `Смены`, `Часы`;
       - `Расходы на топливо`, `Расходы на ремонт`.
   - Блок `Зарплата операторов`:
     - список операторов с полем `Сумма` для каждого (`operator_salaries`).
   - Блок `Комментарий`:
     - текстовое поле.
   - Кнопка `Завершить заявку`.

#### Валидации и локальная логика

- `end_dt` обязателен.
- Для каждой позиции техники:
  - либо `shifts > 0`, либо `hours > 0` (иначе backend вернёт ошибку валидации).
- Для материалов:
  - `quantity > 0`.
- Суммы зарплат не проверяются по общей сумме заказа на клиенте (это доменная логика backend).

#### Взаимодействие с backend

- **Эндпоинт**: `POST /api/v1/orders/{id}/complete/`
- Тело:
  ```json
  {
    "end_dt": "2025-12-01T18:00:00Z",
    "comment": "Работы завершены",
    "operator_salaries": [
      { "operator_id": 3, "salary": "5000.00" }
    ],
    "items": [
      {
        "item_type": "equipment",
        "ref_id": 1,
        "tax_rate": 0,
        "discount": 0,
        "fuel_expense": "1000.00",
        "repair_expense": "0",
        "metadata": {
          "shifts": 1,
          "hours": 2
        }
      }
    ]
  }
  ```
- Backend:
  - очищает старые `OrderItem` и создаёт новые;
  - считает `total_amount` из номенклатуры;
  - создаёт `SalaryRecord` для каждого оператора;
  - создаёт `Expense` по топливу/ремонту;
  - переводит статус в `COMPLETED`;
  - пишет лог в `OrderStatusLog`, очищает кэш отчётов.

#### Ошибки и оффлайн

- При сетевой ошибке:
  - фронт записывает действие `completeOrder` в оффлайн‑очередь;
  - помечает заявку локально как «ожидает синхронизации»;
  - при восстановлении сети синхронизирует действия.

---

### 2.5 Сценарий (Admin/Manager): Просмотр отчётов

**Роли**: `admin` (обязательно), опционально `manager`.  
**Веб‑маршруты**: `/reports/summary`, `/reports/equipment`, `/reports/employees`.

#### Входная точка

- Из дашборда — кнопка `Перейти к отчётам`.
- Из бокового меню — пункты `Отчёты`, `Отчёт по технике`, `Отчёт по сотрудникам`.

#### Шаги

1. **Экран `Общий отчёт` (`/reports/summary`)**
   - Элементы:
     - фильтр периода (`Дата с`, `Дата по`);
     - карточки KPI: `Выручка`, `Расходы`, `Маржа`, `Кол-во заявок`;
     - кнопки экспорта (CSV/XLSX/PDF).
   - Действие:
     - пользователь выбирает период и нажимает «Обновить».
   - Взаимодействие:
     - `GET /api/v1/reports/summary/?from=YYYY-MM-DD&to=YYYY-MM-DD`.
2. **Экран `Отчёт по технике` (`/reports/equipment`)**
   - Таблица по каждой технике:
     - `name`, `code`, `status`;
     - `total_hours`, `revenue`, `expenses`, `fuel_expenses`.
   - Данные: `GET /api/v1/reports/equipment/`.
3. **Экран `Отчёт по сотрудникам` (`/reports/employees`)**
   - Таблица по операторам:
     - `full_name`, `total_amount`, `total_hours`, `assignments`.
   - Данные: `GET /api/v1/reports/employees/`.

#### Особенности

- Backend кэширует результаты в Redis (`report:*`), фронт не должен опираться на это, просто повторно запрашивает при изменении периодов.
- При завершении/удалении заявки backend сам сбрасывает кэш через `clear_reports_cache()`.

---

## ЧАСТЬ 3. ДЕТАЛЬНЫЙ АНАЛИЗ КЛИЕНТА И МАППИНГ НА NEXT.JS

### 3.1 Навигация и карта экранов (универсальная, под Next.js)

#### 3.1.1 Основные секции

- **(auth)**:
  - `/login` — вход.
  - `/register` — регистрация оператора.
- **(app)**:
  - `/` — Dashboard.
  - `/orders` — список заявок.
  - `/orders/create` — создание заявки.
  - `/orders/[orderId]` — карточка заявки.
  - `/orders/[orderId]/edit` — редактирование.
  - `/orders/[orderId]/complete` — завершение.
  - `/catalog/equipment` — техника.
  - `/catalog/services` — услуги.
  - `/catalog/materials` — материалы/грунт.
  - `/catalog/clients` — клиенты.
  - `/reports/summary` — общий отчёт.
  - `/reports/equipment` — отчёт по технике.
  - `/reports/employees` — отчёт по сотрудникам.
  - `/profile` — профиль пользователя.
  - `/profile/password` — смена пароля.
  - `/profile/salary` — зарплата оператора.
  - `/notifications/preferences` — настройки уведомлений.
  - `/offline-queue` — оффлайн‑очередь.

#### 3.1.2 Типы навигации

- Межстраничная навигация:
  - Next.js App Router (`Link`, `router.push()`).
  - Логика guard’ов через:
    - middleware (проверка cookie/токена на сервере);
    - клиентский auth‑guard (проверка `isAuthenticated`).
- Внутри страницы:
  - табы (напр. отчёты, статусы заявок);
  - modals/bottom sheets:
    - выбор номенклатуры;
    - смена статуса заявки;
    - предпросмотр чека PDF (опционально).

#### 3.1.3 Передача параметров

- URL‑параметры:
  - `[orderId]`, `[clientId]` — строковые UUID/числа.
- Query‑параметры:
  - `status`, `search`, `page`, `from`, `to`, фильтры каталога.
- Внутренние параметры:
  - данные форм и выбранные сущности живут:
    - в локальном состоянии компонентов;
    - в React Query cache (`prefetch` для перехода с списка на карточку).

---

### 3.2 State Management (по «атомам») и поток данных

В Flutter используется Riverpod/StateNotifier, в Next.js аналогом будут:
- **React Query** — серверный стейт;
- **Zustand** — минимальный глобальный клиентский стейт;
- локальный `useState` — UI‑мелочи.

#### 3.2.1 Глобальные сторы (Zustand)

- **`useAuthStore`**
  - Состояние:
    - `user: User | null`;
    - `accessToken: string | null`;
    - `refreshToken: string | null`;
    - `isAuthenticated: boolean`;
    - `isLoading: boolean`;
    - `error: string | null`.
  - Методы:
    - `initAuth()`, `login()`, `logout()`, `refreshTokenSafe()`, `autoLoginFromSavedCredentials()`.
  - Источник «правды» для HTTP‑клиента и guard’ов.

- **`useLayoutStore`**
  - Состояние:
    - `activeSection: 'dashboard' | 'orders' | 'catalog' | 'reports' | 'profile' | 'salary' | ...`;
    - `isSidebarOpen: boolean`;
    - `isMobileNavVisible: boolean`;
  - Методы:
    - `setActiveSection(section)`, `toggleSidebar()`.

- **`useOfflineStore`**
  - Состояние:
    - `isOnline: boolean`;
    - `queueSize: number`;
    - `queue: OfflineTask[]`.
  - Методы:
    - `enqueue(task)`, `dequeue(id)`, `syncAll()`, `setOnline(isOnline)`.

#### 3.2.2 Серверный стейт (React Query) — ключевые «атомы»

- **Auth / профиль**
  - `['me']` → `GET /users/me/`.
  - Используется для показа профиля, роли и персонализации.

- **Заявки**
  - `['orders', filters]` → `GET /orders/`.
  - `['order', id]` → `GET /orders/{id}/`.
  - Мутации:
    - `createOrder` → `POST /orders/` + инвалидация `['orders']`;
    - `updateOrder` → `PATCH /orders/{id}/`;
    - `changeOrderStatus` → `PATCH /orders/{id}/status/`;
    - `completeOrder` → `POST /orders/{id}/complete/`;
    - `deleteOrder` → `POST /orders/{id}/delete/`.

- **Каталог**
  - `['catalog', 'equipment', filters]` → `GET /equipment/`;
  - `['catalog', 'services', filters]` → `GET /services/`;
  - `['catalog', 'materials', filters]` → `GET /materials/`;
  - `['clients', filters]` → `GET /clients/`.
  - `staleTime` большой, так как справочники меняются редко.

- **Отчёты**
  - `['reports', 'summary', period]` → `GET /reports/summary/`;
  - `['reports', 'equipment', period]` → `GET /reports/equipment/`;
  - `['reports', 'employees', period]` → `GET /reports/employees/`.

- **Уведомления**
  - `['notifications', 'preferences']` → `GET /notifications/preferences/preferences/`.
  - Мутация `updatePreferences` → `POST` на тот же URL.

- **Зарплаты**
  - `['operatorSalary']` → `GET /users/operator/salary/`.

#### 3.2.3 Поток данных (пример: создание заявки)

1. Пользователь заполняет форму (`CreateOrderForm`).
2. Локальное состояние хранит значения полей, валидация на клиенте.
3. При сабмите:
   - форма вызывает `useMutation(createOrder)`:
     - собирает DTO:
       - создаёт/выбирает клиента;
       - мапит номенклатуру во входной формат backend (тип, `ref_id`, qty и т.п.);
     - вызывает `POST /orders/`.
4. В случае успеха:
   - React Query инвалидирует `['orders']`;
   - навигация на `/orders` или `/orders/[id]`.
5. В случае ошибки сети:
   - формируется `OfflineTask` (`{ type: 'CREATE_ORDER', payload: dto }`);
   - кладётся в `useOfflineStore.queue`;
   - UI показывает, что заявка «подвешена» до синхронизации.

---

### 3.3 Архитектура компонентов (Widget/Component Tree)

Рекомендуемая атомарная структура под Next.js (Tailwind + headless‑компоненты).

#### 3.3.1 Атомы (базовые переиспользуемые компоненты)

- **`Button`**
  - Props:
    - `variant: 'primary' | 'secondary' | 'ghost' | 'danger'`;
    - `size: 'sm' | 'md' | 'lg'`;
    - `isLoading?: boolean`;
    - остальные HTML‑props.
  - Состояние: нет (кроме `:hover/:active`).

- **`Input`**
  - Props:
    - `label?: string`;
    - `error?: string`;
    - `hint?: string`;
    - `type?: 'text' | 'password' | 'number' | ...`.

- **`Select` / `Combobox`**
  - Используются для выбора статуса, операторов, клиентов, периодов отчётов.

- **`Badge`**
  - Варианты под статусы заявок/техники/платежей:
    - цвета и подписи соответствуют `OrderStatus` и `EquipmentStatus`.

- **`Spinner` / `LoadingIndicator`**
  - Используется во всех состояниях загрузки.

- **`Alert`**
  - Варианты: `error`, `warning`, `info`, `success`.
  - Используется для ошибок API, оффлайн‑состояния и т.п.

#### 3.3.2 Молекулы

- **`SearchBar`**
  - Состоит из `Input` + иконка поиска + debounce логика.
  - Используется в списке заявок, каталоге, клиентах.

- **`KpiCard`**
  - Название KPI, значение, иконка, тренд.
  - Используется на Dashboard и в отчётах.

- **`OrderCard`**
  - Представление заявки в виде карточки (для mobile).
  - Props:
    - `order: Order`.
  - Использует:
    - `Badge` для статуса;
    - текстовые поля для клиента, адреса, дат, суммы.

- **`OrderTableRow`**
  - Строчка в таблице заявок (desktop).

- **`FormField`**
  - Обёртка над `label + control + error`.
  - Используется во всех формах (логин, заявка, профиль).

#### 3.3.3 Организмы (крупные блоки экранов)

- **`CreateOrderForm`**
  - Объединяет:
    - блок клиента;
    - блок заявки;
    - выбор операторов;
    - номенклатуру;
    - финансы.
  - Управляет:
    - локальным состоянием формы;
    - вызовом API `POST /orders/` и оффлайн‑очередью.

- **`OrdersList`**
  - Табы статусов;
  - поиск;
  - таблица/список карточек;
  - интеграция с React Query (`['orders', filters]`).

- **`OrderDetailView`**
  - Объединяет:
    - инфоблок по заявке;
    - список позиций;
    - статусный таймлайн;
    - блок фото;
    - actions‑панель (редактировать, завершить, удалить).

- **`CompleteOrderForm`**
  - Организм для `/orders/[id]/complete`:
    - формы для смен/часов;
    - номенклатуры;
    - зарплат операторов;
    - комментария.

- **`ReportsSummaryView` / `EquipmentReportView` / `EmployeesReportView`**
  - Организмы для трёх отчётных страниц.

- **`ProfileView`, `OperatorSalaryView`, `NotificationPreferencesView`**
  - Организмы для соответствующих страниц профиля.

#### 3.3.4 Шаблоны (Layouts)

- **`AuthLayout`**
  - Шапка с логотипом, центральная форма, фон.
  - Используется для `/login`, `/register`.

- **`AppLayout`**
  - Верхний AppBar (заголовок, быстрые действия, профиль);
  - Sidebar (desktop) + BottomNav (mobile);
  - `OfflineBanner` и `OfflineQueueIndicator`;
  - слот `children` для страниц.

- **`PageWithFilters`**
  - Обёртка для страниц со списками:
    - блок фильтров сверху;
    - список/таблица ниже;
    - общий хедер (название раздела).

#### 3.3.5 Страницы (Next.js `page.tsx`)

Каждая страница:
- подготавливает данные (через React Query hooks/Server Components);
- рендерит один или несколько организмов;
- **не** содержит тяжёлой логики — она вынесена в хуки/сервисы.

Примеры:
- `/orders/page.tsx` → `<OrdersList />`.
- `/orders/[id]/page.tsx` → `<OrderDetailView orderId={params.orderId} />`.
- `/orders/create/page.tsx` → `<CreateOrderForm />`.
- `/reports/summary/page.tsx` → `<ReportsSummaryView />`.

---

## ЧАСТЬ 4. BACKEND API: ОПОРНЫЙ СПИСОК ДЛЯ НОВОГО ФРОНТА

Ниже — краткая опорная таблица (полные детали уже есть в `ReactWeb_Inventory.md`, но здесь достаточно для реализации фронта).

### 4.1 Auth и пользователи

- `POST /api/v1/token/` — логин (`phone|email|username`, `password`) → `access`, `refresh`.
- `POST /api/v1/token/refresh/` — обновление access по refresh.
- `POST /api/v1/token/blacklist/` — logout (best effort).
- `GET /api/v1/users/me/` — текущий пользователь.
- `POST /api/v1/users/register/` — регистрация оператора.
- `POST /api/v1/users/change-password/` — смена пароля.
- `GET /api/v1/users/operators/` — список операторов.
- `GET /api/v1/users/operator/salary/` — зарплаты текущего оператора.

### 4.2 Заявки

- `GET /api/v1/orders/` — список заявок (фильтры: `status`, `search`, пагинация).
- `GET /api/v1/orders/{id}/` — деталь заявки.
- `POST /api/v1/orders/` — создание заявки.
- `PATCH /api/v1/orders/{id}/` — обновление заявки.
- `PATCH /api/v1/orders/{id}/status/` — смена статуса (кроме `COMPLETED`).
- `POST /api/v1/orders/{id}/complete/` — завершение заявки.
- `POST /api/v1/orders/{id}/attachments/` — presigned‑URL для загрузки вложения.
- `GET /api/v1/orders/{id}/receipt/` — PDF‑чек.
- `POST /api/v1/orders/{id}/generate_invoice/` — генерация инвойса.
- `POST /api/v1/orders/{id}/delete/` — полное удаление заявки.

### 4.3 Каталог и клиенты

- `GET /api/v1/equipment/` — техника (фильтр `status`, поиск).
- `GET /api/v1/services/` — услуги (фильтр `category`, `is_active`, поиск).
- `GET /api/v1/materials/` — материалы (фильтр `category`, `is_active`, поиск).
- `GET /api/v1/clients/` — список клиентов (фильтр `is_active`, `city`, поиск).
- `POST /api/v1/clients/` — создание клиента.

### 4.4 Отчёты

- `GET /api/v1/reports/summary/` — общий отчёт (параметры `from`, `to`, `export?`).
- `GET /api/v1/reports/equipment/` — отчёт по технике.
- `GET /api/v1/reports/employees/` — отчёт по сотрудникам.

### 4.5 Уведомления

- `POST /api/v1/notifications/device-tokens/` — регистрация токена устройства.
- `GET /api/v1/notifications/preferences/preferences/` — текущие настройки.
- `POST /api/v1/notifications/preferences/preferences/` — обновление настроек.
- `GET /api/v1/notifications/preferences/logs/` — история уведомлений (опциональный экран).

---

## ЧАСТЬ 5. ОФФЛАЙН И КЭШ В НОВОМ ФРОНТЕ

### 5.1 Кэш серверных данных

- Используем React Query + IndexedDB/localStorage:
  - при успешных запросах к `/orders`, `/equipment`, `/clients`, `/reports/...`:
    - сериализуем ответ и дополнительно кладём в localStorage/IndexedDB;
  - при ошибке сети:
    - пробуем взять последнюю версию из локального кэша;
    - помечаем данные как `isFromCache`.

### 5.2 Оффлайн‑очередь действий

- Тип `OfflineTask`:
  - `{ id, type: 'CREATE_ORDER' | 'UPDATE_ORDER' | 'COMPLETE_ORDER' | 'CHANGE_STATUS', payload, createdAt }`.
- Механика:
  1. При неудачном запросе (сетевой/timeout):
     - формируем `OfflineTask` и пишем в `useOfflineStore.queue` + persist в storage.
  2. На восстановление сети:
     - `syncAll()` по очереди:
       - воспроизводит запросы к backend;
       - при успехе помечает task как выполненный и удаляет;
       - при повторной ошибке сети — останавливается.
  3. UI:
     - `/offline-queue` — список задач с возможностью удаления/повторного запуска;
     - `OfflineQueueIndicator` — чип с числом задач в AppBar/BottomNav.

### 5.3 Детектор сети и `OfflineBanner`

- Подписка на `window.navigator.onLine` и периодический ping `/api/health/`.
- Если сеть недоступна:
  - `isOnline = false` в `useOfflineStore`;
  - `OfflineBanner` показывает жёлтое уведомление;
  - мутации переключаются в «offline‑mode» (с записью в очередь).

---

## ЧАСТЬ 6. ПЛАН ВНЕДРЕНИЯ НА NEXT.JS (РЕКОМЕНДУЕМЫЙ ПОРЯДОК)

1. **Базовый каркас**
   - Настроить Next.js 14 (App Router), Tailwind, Zustand, React Query.
   - Реализовать `httpClient` с interceptor’ами (auth + retry по refresh).
   - Сделать `useAuthStore` и `AuthProvider`.
2. **Auth и layout**
   - Страницы `/login`, `/register` с `AuthLayout`.
   - `(app)/layout.tsx` с `AppLayout` и заглушкой «Добро пожаловать, {user}».
3. **Заявки**
   - `/orders` — список (React Query + фильтры).
   - `/orders/create` — `CreateOrderForm` с интеграцией `/clients`, `/users/operators/`.
   - `/orders/[id]` — `OrderDetailView`.
   - `/orders/[id]/edit` и `/orders/[id]/complete`.
4. **Каталог и клиенты**
   - `/catalog/equipment`, `/catalog/services`, `/catalog/materials`, `/catalog/clients`.
5. **Профиль и зарплаты**
   - `/profile`, `/profile/password`, `/profile/salary`.
6. **Отчёты**
   - `/reports/summary`, `/reports/equipment`, `/reports/employees`.
7. **Оффлайн и уведомления**
   - Реализация `useOfflineStore`, `OfflineBanner`, `OfflineQueue` и привязка к мутациям.
   - Настройки уведомлений и регистрацию device‑token (web push / FCM web).

Следуя этому документу и уже существующим файлам `ReactWeb_Architecture.md`, `ReactWeb_NextParitySpec.md` и `ReactWeb_Inventory.md`, можно по шагам реализовать новый Next.js фронт, полностью повторяющий функциональность текущего Flutter‑клиента и правильно интегрированный с Django backend.


